"""
dhcp_manager.py — Generate dnsmasq configuration and manage the DHCP server process.
"""

import subprocess
import signal
import os
import tempfile
import logging
import time
import ipaddress
from typing import Optional

logger = logging.getLogger(__name__)

DNSMASQ_TEMPLATE = """# Auto-generated by wifi-extender
# Only listen on the AP interface
interface={interface}
bind-interfaces

# DHCP range
dhcp-range={range_start},{range_end},{lease_time}

# Gateway and DNS
dhcp-option=3,{gateway}
dhcp-option=6,{dns}

# Don't read /etc/resolv.conf or hosts — keep it isolated
no-resolv
no-hosts

# Upstream DNS servers
server=8.8.8.8
server=8.8.4.4
server=1.1.1.1

# Logging
log-queries
log-dhcp

# PID file
pid-file={pid_file}
"""


class DHCPManager:
    """Manages dnsmasq — DHCP + DNS for the AP subnet."""

    def __init__(
        self,
        interface: str,
        gateway: str,
        subnet: str = "192.168.4.0/24",
        lease_time: str = "12h",
    ):
        self.interface = interface
        self.gateway = gateway
        self.subnet = ipaddress.IPv4Network(subnet, strict=True)
        self.lease_time = lease_time

        # Calculate DHCP range: .10 to .200 within the subnet
        hosts = list(self.subnet.hosts())
        self.range_start = str(hosts[9])     # .10
        self.range_end = str(hosts[min(199, len(hosts) - 2)])  # .200 or max
        self.dns = "8.8.8.8"

        self._config_path: Optional[str] = None
        self._pid_file: Optional[str] = None
        self._process: Optional[subprocess.Popen] = None

    def generate_config(self) -> str:
        """Generate dnsmasq config file. Returns the path."""
        fd_pid, pid_path = tempfile.mkstemp(prefix="dnsmasq_", suffix=".pid")
        os.close(fd_pid)
        self._pid_file = pid_path

        config = DNSMASQ_TEMPLATE.format(
            interface=self.interface,
            range_start=self.range_start,
            range_end=self.range_end,
            lease_time=self.lease_time,
            gateway=self.gateway,
            dns=self.dns,
            pid_file=self._pid_file,
        )

        fd, path = tempfile.mkstemp(prefix="dnsmasq_", suffix=".conf")
        with os.fdopen(fd, "w") as f:
            f.write(config)

        self._config_path = path
        logger.info(f"dnsmasq config written to {path}")
        logger.debug(f"DHCP range: {self.range_start} - {self.range_end}")
        return path

    def start(self) -> None:
        """Start the dnsmasq process."""
        if self._process is not None:
            raise RuntimeError("dnsmasq is already running")

        if self._config_path is None:
            self.generate_config()

        # Kill any existing dnsmasq on this interface (common source of conflicts)
        self._kill_existing()

        logger.info(f"Starting dnsmasq on {self.interface}")

        self._process = subprocess.Popen(
            [
                "dnsmasq",
                f"--conf-file={self._config_path}",
                "--no-daemon",  # Stay in foreground so we can manage it
                "--log-facility=-",  # Log to stderr
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )

        # Brief wait to catch early failures
        time.sleep(0.5)
        if self._process.poll() is not None:
            output = self._process.stdout.read() if self._process.stdout else ""
            raise RuntimeError(
                f"dnsmasq exited immediately (code {self._process.returncode}):\n{output}"
            )

        logger.info(f"dnsmasq started (PID: {self._process.pid})")

    def _kill_existing(self) -> None:
        """Kill any dnsmasq instances that might conflict."""
        result = subprocess.run(
            ["pgrep", "-f", f"dnsmasq.*{self.interface}"],
            capture_output=True, text=True,
        )
        for pid_str in result.stdout.strip().splitlines():
            pid = int(pid_str.strip())
            logger.warning(f"Killing existing dnsmasq (PID {pid}) on {self.interface}")
            try:
                os.kill(pid, signal.SIGTERM)
                time.sleep(0.3)
            except ProcessLookupError:
                pass

    def stop(self) -> None:
        """Stop the dnsmasq process."""
        if self._process is None:
            return

        logger.info("Stopping dnsmasq...")
        try:
            self._process.send_signal(signal.SIGTERM)
            self._process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            logger.warning("dnsmasq didn't exit in 5s, sending SIGKILL")
            self._process.kill()
            self._process.wait(timeout=3)
        finally:
            self._process = None

        # Clean up temp files
        for path in (self._config_path, self._pid_file):
            if path and os.path.exists(path):
                os.unlink(path)
        self._config_path = None
        self._pid_file = None

        logger.info("dnsmasq stopped")

    @property
    def is_running(self) -> bool:
        return self._process is not None and self._process.poll() is None

    def get_leases(self) -> list[dict]:
        """
        Read the DHCP lease table.
        Returns list of dicts: {mac, ip, hostname, expiry}.
        """
        lease_file = "/var/lib/misc/dnsmasq.leases"
        if not os.path.exists(lease_file):
            # Some systems use a different path
            lease_file = "/tmp/dnsmasq.leases"
        if not os.path.exists(lease_file):
            return []

        leases = []
        with open(lease_file, "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) >= 4:
                    leases.append({
                        "expiry": parts[0],
                        "mac": parts[1],
                        "ip": parts[2],
                        "hostname": parts[3] if parts[3] != "*" else "(unknown)",
                    })
        return leases