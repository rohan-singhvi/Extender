"""
ap_manager.py — Generate hostapd configuration and manage the hostapd process.
"""

import subprocess
import signal
import os
import tempfile
import logging
import time
from typing import Optional

logger = logging.getLogger(__name__)

# Default hostapd config template
HOSTAPD_TEMPLATE = """# Auto-generated by wifi-extender
interface={interface}
driver=nl80211

# Network
ssid={ssid}
hw_mode={hw_mode}
channel={channel}
country_code={country_code}

# Security
wpa=2
wpa_passphrase={passphrase}
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP

# Performance
wmm_enabled=1
ieee80211n=1

# Logging
logger_syslog=-1
logger_syslog_level=2
logger_stdout=-1
logger_stdout_level=2
"""

# Extra lines for 5GHz / 802.11ac
AC_EXTRAS = """
ieee80211ac=1
ht_capab=[HT40+][SHORT-GI-20][SHORT-GI-40]
vht_oper_chwidth=1
"""


class APManager:
    """Manages hostapd — the software access point daemon."""

    def __init__(
        self,
        interface: str,
        ssid: str = "WifiExtender",
        passphrase: str = "changeme123",
        channel: int = 6,
        hw_mode: str = "g",
        country_code: str = "US",
    ):
        self.interface = interface
        self.ssid = ssid
        self.passphrase = passphrase
        self.channel = channel
        self.hw_mode = hw_mode  # 'g' = 2.4GHz, 'a' = 5GHz
        self.country_code = country_code

        self._config_path: Optional[str] = None
        self._process: Optional[subprocess.Popen] = None

    def validate(self) -> list[str]:
        """Validate configuration. Returns list of error strings (empty = OK)."""
        errors = []

        if not self.ssid or len(self.ssid) > 32:
            errors.append("SSID must be 1-32 characters")

        if len(self.passphrase) < 8 or len(self.passphrase) > 63:
            errors.append("WPA2 passphrase must be 8-63 characters")

        if self.hw_mode not in ("a", "b", "g"):
            errors.append(f"Invalid hw_mode '{self.hw_mode}' — use 'a' (5GHz) or 'g' (2.4GHz)")

        if self.hw_mode == "g" and not (1 <= self.channel <= 14):
            errors.append(f"Channel {self.channel} invalid for 2.4GHz (1-14)")

        if self.hw_mode == "a" and self.channel not in (
            36, 40, 44, 48, 52, 56, 60, 64,
            100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,
            149, 153, 157, 161, 165,
        ):
            errors.append(f"Channel {self.channel} invalid for 5GHz")

        return errors

    def generate_config(self) -> str:
        """Generate hostapd configuration and write to a temp file. Returns the path."""
        config = HOSTAPD_TEMPLATE.format(
            interface=self.interface,
            ssid=self.ssid,
            hw_mode=self.hw_mode,
            channel=self.channel,
            passphrase=self.passphrase,
            country_code=self.country_code,
        )

        if self.hw_mode == "a":
            config += AC_EXTRAS

        fd, path = tempfile.mkstemp(prefix="hostapd_", suffix=".conf")
        with os.fdopen(fd, "w") as f:
            f.write(config)

        self._config_path = path
        logger.info(f"hostapd config written to {path}")
        logger.debug(f"Config:\n{config}")
        return path

    def start(self) -> None:
        """Start the hostapd process."""
        if self._process is not None:
            raise RuntimeError("hostapd is already running")

        if self._config_path is None:
            self.generate_config()

        logger.info(f"Starting hostapd on {self.interface} (SSID: {self.ssid}, ch: {self.channel})")

        self._process = subprocess.Popen(
            ["hostapd", self._config_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
        )

        # Give hostapd a moment to start and check for early failures
        time.sleep(1.5)
        if self._process.poll() is not None:
            output = self._process.stdout.read() if self._process.stdout else ""
            raise RuntimeError(
                f"hostapd exited immediately (code {self._process.returncode}):\n{output}"
            )

        logger.info(f"hostapd started (PID: {self._process.pid})")

    def stop(self) -> None:
        """Stop the hostapd process gracefully."""
        if self._process is None:
            return

        logger.info("Stopping hostapd...")
        try:
            self._process.send_signal(signal.SIGTERM)
            self._process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            logger.warning("hostapd didn't exit in 5s, sending SIGKILL")
            self._process.kill()
            self._process.wait(timeout=3)
        finally:
            self._process = None

        # Clean up config file
        if self._config_path and os.path.exists(self._config_path):
            os.unlink(self._config_path)
            self._config_path = None

        logger.info("hostapd stopped")

    @property
    def is_running(self) -> bool:
        return self._process is not None and self._process.poll() is None

    def read_output(self, timeout: float = 0.1) -> Optional[str]:
        """Non-blocking read of hostapd stdout (for log display)."""
        if self._process and self._process.stdout:
            import select
            ready, _, _ = select.select([self._process.stdout], [], [], timeout)
            if ready:
                return self._process.stdout.readline()
        return None